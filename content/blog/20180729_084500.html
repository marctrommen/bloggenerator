<!-- blogtitle: Mock mit Python3 -->
<!-- blogcreated: 20180729-084500 -->
<!-- blogchanged: 20180805-190000 -->
<!-- blogkeywords: code, python, mock -->

<h1>What is Mock?</h1>

<blockquote>
<p>"mock allows you to <strong>replace parts of your system under test</strong> with mock
objects and <strong>make assertions about how they have been used</strong>."</p>
</blockquote>

<p>Links:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=7XiArCSZc3g">My Adventures with Mock</a></li>
<li><a href="https://www.youtube.com/watch?v=lwkDSOVKD7U">Building microservices in Python - Tarek Ziade</a></li>
<li><a href="https://www.youtube.com/watch?v=VhabrYF1nms">Building Python apps with Docker</a></li>
<li><a href="https://www.youtube.com/watch?v=iQU18hAjux4">Practical PyBuilder</a></li>
</ul>


<h1>Unit Testing</h1>

<ul>
<li>Exercise part of your code (fuction or method)</li>
<li>Verify the side-efficts</li>
<li>May verify state change</li>
</ul>

<h1>Typical Unit Test</h1>

<pre><code class="python">
import unittest

def add(x, y):
	return x + y

class TestAdd(unittest.TestCase):

	def test_add(self):
		result = add (40, 2)
		self.assertEqual(result, 42)
</code></pre>


<h1>Unit Test of Code with Further Dependencies</h1>

<pre><code class="python">
def add_service(x,y):
	resp = requests.post(
		"http://math.biz/sum",
		{'operands': [x, y]}
	)
	return resp.json()

class TestAdd(unittest.TestCase):

	def test_add_service(self):
		result = add_service (40, 2)
		self.assertEqual(result, 42)
</code></pre>

<p>Bad unit test, because of ...</p>
<ul>
<li>further dependencies</li>
<li>service might not be available</li>
<li>internet connection might not be available</li>
</ul>


<h1>Mock Objects</h1>

<ul>
<li>Flexible objects that replace other parts of your code</li>
<li>callable</li>
<li>create attributes when accessed (new Mock objects)</li>
<li>Record how they are used (and you can make assertions about that!)</li>
</ul>


<h1>Use Mock Objects</h1>

<ul>
<li>replace part of your code with something you can inspect!</li>
<li>Replaces <strong>requests</strong> with a mock object</li>
<li>Assert that <code>request.post</code> was called with <strong>correct parameters</strong></li>
</ul>


<h1><code>from mock import patch</code></h1>

<ul>
<li>Temporarlily replaces a named object with a Mock object</li>
<li>e.g. replaces <code>requests</code> with an instance of Mock</li>
<li><em>patch</em> where your code <em>looks</em> for an object</li>
</ul>

<pre><code class="python">
# main.py

import requests

def add_service(x,y):
	resp = requests.post(
		"http://math.biz/sum",
		{'operands': [x, y]}
	)
	return resp.json()
</code></pre>

<pre><code class="python">
# test.py

import unittest
from unittest.mock import patch
from main import add_service

class TestAdd(unittest.TestCase):

	def test_add_service(self):
		with patch("main.requests") as mock_requests:
			add_service(40,2)  # call the function under test
			
			mock_requests.post.assert_called_once_with(
				"http://math.biz/sum",
				{'operands': [x, y]}
			)
</code></pre>


<h1>Other Mocking Opportunities</h1>

<ul>
<li>Code that hits external APIs or network ressources</li>
<li>Exception handler code</li>
<li>Expensive code (e.g. memory / time / IO expensive)</li>
<li>code that needs a lot of setup</li>
</ul>


<h2>testing Exception Handlers</h2>

<pre><code class="python">
# main.py

import json
import logging
import requests
from requests import ConnectionError, HTTPError

# ...

def get_content(url):
	try:
		response = requests.get(url)
		result = json.loads(response.json())
	except (ConnectionError, HTTPError):
		logging.warn("No Result")
		result = {}
	return result
</code></pre>

<pre><code class="python">
# test.py

from main import add_service, get_content
from unittest.mock import patch
import requests
import unittest

class TestAdd(unittest.TestCase):

	# ...
	def test_content_exception_handler(self):
		with patch("main.requests") as mock_requests:
		
			url = "http://example.com"
			
			# raise exception as a side effect
			mock_requests.get.side_effect = requests.HTTPError
			
			# call the function under test
			result = get_content(url)
			
			mock_requests.get.assert_called_once_with(url)
			
			self.assertEqual(result, {})
</code></pre>

<p>Mock's <code>side_effect</code></p>
<ul>
<li>controls the <em>side effects</em> of calling a method</li>
<li>can raise exceptions</li>
<li>can also produce dynamic results for function/method calls
checkout documentation for further excamples</li>
</ul>


<h2>combine testing and mocking with coverage</h2>

<p>run coverage-test:</p>
<pre><code>$> coverage run test.py && coverage report
</code></pre>


<h2>testing expensive code</h2>

<p><em>Expensive Code</em> could be with a lot of memory, time consumption or with a lot
of IO traffic (e.g. file-handling, database connections) or web ressources
without 100% availability guaranteed</p>

<pre><code class="python">
# main.py

class SciWhizBang(object):

	def _calc(self, value):
		import time
		time.sleep(1000) # Expensive!
		return value + 1
	
	def calc_alpha(self):
		return self._calc(100)
	
	def calc_beta(self):
		return self._calc(999)
</code></pre>

<p>Question:<br>
How to test <code>calc_alpha()</code> without running expensive <code>time.sleep()</code>?</p>

<pre><code class="python">
#tests.py

class TestSciWhizBang(unittest.TestCase):

	@patch.object(SciWhizBang, "_calc", return_value=42)
	def test_calc_alpha(self, mock_calc):
	
		obj = SciWhizBang()
		
		self.assertEqual(obj.calc_alpha(), 42)
		
		mock_calc.user_called_once_witz(100)
</code></pre>

<p>Using mock's <code>patch.object</code> as a <em>decorator</em> for replacing a method of a class.
In it definition,</p>
<ul>
<li><code>SciWhizBang</code> is the referenced object/class</li>
<li><code>"_calc"</code> is the replaced method od the referneced object</li>
<li><code>return_value=42</code> is the method's fixed return value, each time it is called</li>
<li>the patched definition is getting passed into <code>test_cald_alpha()</code> as
parameter <code>mock_calc</code></li>
</ul>

<p>With <code>mock_calc.assert_called_once_with(100)</code> we can test the call parameters
of the patched method.</p>

<p>All the test tests now the logic of method <code>calc_alpha()</code> whithout testing
<code>_calc()</code> as an integration test and without the time consuming part of it.</p>


<h2>testing code that needs a lot of setup</h2>

<p>If your code uses other objects (aggregation of behaviour) you can mock the
behaviour of the used objects without setting them up.</p>

<p>Therefore you can customize mock objects in various ways, like:</p>
<ul>
<li>set attribute values</li>
<li>set method return values</li>
<li>create chains of method calls</li>
</ul>


<h3>usage of config dictionary</h3>

<pre><code class="python">
config = {
	'first_name': 'Alan',
	'last_name': 'Turing',
	'email': 'turing@example.com'
	'get_achievement.return_value': 'Computing',
	'get_age.side_effect': ValueError
}
m = Mock(**config)
</code></pre>

<p>running it in Python console:</p>
<pre><code>
>>> m.first_name
'Alan'

>>> m.get_achievement()
'Computing'

>>> m.get_age()
ValueError
</code></pre>


<h3>usage of spec'd objects</h3>

<ul>
<li>creates a <em>white list</em> of available attribute and method names</li>
<li>Anything else raises an <code>AttributeError</code></li>
</ul>

<pre><code class="python">
user_spec = [
	'first_name', 'last_name',
	'email', 'get_full_name'
]
m = Mock(spec = user_spec)
</code></pre>

<p>running it in Python console:</p>
<pre><code>
>>> m.get_full_name()
<Mock name='mock.get_full_name()' id='4311640208'>

>>> m.password
AttributeError
</code></pre>


<h3>usage of Autospec</h3>

<ul>
<li>automatically creates a spec from an existing object</li>
<li>anything else raises an <code>AttributeError</code></li>
</ul>

<pre><code class="python">
from mock import create_autospec
>>> u = User.objects.get(pk=1)
>>> m = create_autospec(u)

>>> m.get_full_name()
<MagicMock name='mock.get_full_name()' id='4504021136'>

>>> m.something_else()
AttributeError
</code></pre>


<h1>Summary on Mock</h1>

<ul>
<li>create Mock objects instead of loading fixtures</li>
<li>narrowly define your Mock object's behavior / ExpectAssertions if they are
used incorrectly</li>
<li>rely on Spec/Autospec'd objects as test objects</li>
</ul>


<h1>Tips on Mock</h1>

<ul>
<li>The <a href="http://www.voidspace.org.us/python/mock/">Documentation</a> is awesome
<ul>
<li>tons of examples for various scenarios!</li>
<li>but lacks with the <em>philosophy behind (good)mocking</em></li>
</ul>
</li>
<li>better search on Google with the search string<br>
<code>"from mock import" site:github.com</code>
<a href="https://www.google.de/search?q=%22from+mock+import%22+site%3Agithub.com">Search</a><br>
it will show you, how others are using <code>mock</code> in their <em>real life projects</em></li>
</ul>
